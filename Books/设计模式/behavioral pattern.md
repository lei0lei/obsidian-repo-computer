## 0.Chain of Responsibility
## 介绍

责任链模式允许请求沿着处理链进行传递，每个处理者接收到请求时可以选择自行处理或者传递给链中的下一个处理者。

![[Pasted image 20250530171538.png|400]]

想象你正在开发一个在线订购系统。你希望限制系统的访问权限，只有通过身份验证的用户才能创建订单。同时，具有管理员权限的用户应拥有对所有订单的完全访问权限。

经过一番规划后，你意识到这些检查必须按顺序执行。当应用接收到包含用户凭证的请求时，应首先尝试对用户进行身份验证。然而，如果凭证无效，认证失败，就没有理由继续执行后续的任何检查。

![[Pasted image 20250530171719.png|400]]

接下来的几个月里，你实现了更多这样的顺序检查。

你的一个同事指出，将原始数据直接传给订购系统是不安全的。于是你增加了一个额外的验证步骤，用于清洗请求中的数据。

后来，有人发现系统容易受到暴力破解密码的攻击。为了解决这个问题，你迅速添加了一个检查，用于过滤来自同一 IP 地址的重复失败请求。

还有人建议，为了加快系统响应速度，可以在遇到相同数据的重复请求时返回缓存结果。因此，你又添加了一个检查，只有在没有合适的缓存响应时，请求才会继续传递到系统中。

![[Pasted image 20250530171813.png|400]]

和许多其他行为型设计模式一样，职责链模式的核心是将特定的行为封装成独立的对象，称为处理者（Handler）。在我们的例子中，每个检查都应被提取为一个独立的类，该类中包含一个执行检查的方法。请求及其相关数据会作为参数传入这个方法中。

该模式建议将这些处理者连接成一条链。每个处理者都包含一个字段，用于存储对链中下一个处理者的引用。除了处理请求外，处理者还会将请求传递给链中的下一个处理者。请求会沿着链依次传递，直到所有处理者都有机会处理它为止。

最关键的一点是：处理者可以选择不再向下传递请求，从而有效地中止后续处理。

在我们的订购系统示例中，每个处理者在完成自己的处理逻辑后，可以决定是否将请求继续向下传递。只要请求数据有效，所有处理者都可以执行自己的主要功能，无论是身份验证、缓存检查还是数据清洗等。

![[Pasted image 20250530172205.png|400]]
不过，还有一种稍有不同但更常见的方式：当处理者接收到请求时，会判断自己是否能够处理它。如果可以，它就直接处理请求而不再传递下去。也就是说，请求要么被某一个处理者处理，要么就不被处理。这种方式在图形用户界面（GUI）中的事件处理机制中非常常见。

比如，当用户点击一个按钮时，事件会沿着一条由 GUI 元素组成的链进行传播，起点是按钮，然后是它的容器（如表单或面板），最终到达主窗口。事件会被链中第一个能处理它的元素接收并处理。这也说明，职责链可以从对象树中提取出来使用。

![[Pasted image 20250530172511.png|400]]

所有处理者类实现相同的接口是至关重要的。每个具体的处理者只需关心下一个处理者是否具有 `execute` 方法。通过这种方式，你可以在运行时灵活地组合不同的处理链，而无需将代码耦合到具体的处理者类上。

![[Pasted image 20250530172726.png|400]]

1. 处理者（Handler）声明了所有具体处理者共有的接口。它通常只包含一个用于处理请求的方法，但有时也会包含一个用于设置链中下一个处理者的方法。
2. 基础处理者（Base Handler）是一个可选的类，用于放置所有处理者类共有的模板代码。通常，这个类会定义一个字段，用来存储对下一个处理者的引用。客户端可以通过将一个处理者传递给前一个处理者的构造函数或设置方法，来构建处理链。该类还可能实现默认的处理行为：在确认下一个处理者存在后，将请求传递给它继续处理。
3. 具体处理者（Concrete Handlers）包含实际处理请求的代码。每个处理者在接收到请求后，必须决定是否处理该请求，以及是否将请求传递给链中的下一个处理者。处理者通常是自包含且不可变的，只在构造函数中接收一次所需的所有数据。
4. 客户端可以根据应用逻辑，选择只组装一次处理链，也可以动态地组装处理链。需要注意的是，请求可以发送给链中任意一个处理者，不一定非要从第一个处理者开始


## 适用场景  
当程序需要以多种方式处理不同类型的请求，但事先无法确定请求的具体类型和顺序时，适合使用职责链模式。

该模式允许你将多个处理者连接成一条链，并在接收到请求时依次“询问”每个处理者是否能处理请求，从而让所有处理者都有机会处理请求。

当必须按特定顺序执行多个处理者时，也应使用此模式。

由于处理者在链中的顺序可以自由组合，所有请求都会按照预期顺序经过处理链。

当处理者的集合及其顺序需要在运行时动态变化时，职责链模式尤为合适。

如果在处理者类中提供设置下一个处理者的 setter 方法，就可以动态插入、删除或调整处理者的顺序。


---
## 1.Command


---
## 2.Iterator

---
## 3.Mediator

---
## 4.Memento
---
## 5.Observer

---
## 6.State
---
## 7.Strategy
---
## 8.Template Method
---
## 9.Visitor